# 3.3 배포 및 운영 최적화 전략: 서버 아키텍처의 다양한 옵션

## 3.3.1 서버리스 아키텍처의 이해: 주요 구성 요소와 장단점

서버리스 컴퓨팅 - 서버 관리를 추상화해 개발자에게서 분리하는 개념<br>

- 개발자가 인프라에 대한 걱정없이 개발과 운영에 집중 할 수 있게됨
- 사용한 컴퓨팅 시간만 비용 지불하는 구조여서 효율적임

![](./img/15.jpg)

#### 서버리스 아키텍처의 구성요소

- `서비스형 함수(Functions-as-a-Service, FaaS)`<br>
  서버리스 아키텍처의 기본<br>
  앱 기능을 독립적인 함수로 배포<br>
  함수의 스케일링은 클라우드 제공자가 관리
- `서비스형 백엔드(Backend-as-a-Service)`<br>
  인증, DB, 파일 저장소 등의 서비스를 외부 제공 업체가 관리함<br>
  전통적인 백엔드 서버의 필요성이 감소하고 프론트엔드와 직접 통합됨
- `API 게이트웨이`<br>
  HTTP 요청을 처리하고 적절한 함수나 서비스로 라우팅하는 역할(진입점)
- `이벤트 트리거`<br>
  상태 변경이나 데이터 업데이트가 함수를 실행<br>
  동적이고 반응적인 앱을 가능하게 하는 트리거 역할

![](./img/16.jpg)

### 서버리스 아키텍처의 이점

1. **운영 비용 감소**<br>
   서버를 직접 관리하지 않아서 개발자는 개발에 집중 가능
2. **비용 효율성**<br>
   사용량 기반으로 비용을 지불해 불필요한 비용 절감
3. **확장성과 유연성**<br>
   서비스 확장이 쉽고 복잡한 서버 환경 설정에 대한 걱정이 없음<br>
   트래픽 변화에 빠르게 적응 가능
4. **배포, 업데이터 과정이 간소함**<br>
   CI/CD 가 더 간단해짐

### 서버리스 아키텍처 도입 시 고려 사항

1. **콜드 스타트 문제**<br>
   서버리스 함수가 일정 시간 활성화되지 않으면<br>
   다시 활성화 되는데 추가 시간이 필요함
2. **벤더 종속성**<br>
   특정 클라우드 업체의 서비스와 밀접하므로 <br>
   제공업체의 서비스 변경이나 가격 정책에 큰 영향을 받음
3. **제한된 제어 권한 문제**<br>
   서버리스는 서버 관리에 대한 직접적인 제어를 줄여주지만<br>
   일부 복잡한 작업을 수행하는 데 제약이 될 수 있음
4. **디버깅과 모니터링 어려움**<br>
   디버깅과 모니터링을 위해 새로운 전략이나 도구를 개발하고 적용해야 할 수 있음

### Next.js 와 서버리스

Next.js의 구조는 애플리케이션을 람다 함수처럼 개별적으로 분할하고 독립적으로 배포하는데 도움을 줌(API 라우트)

Next.js 의 API 핸들러는 함수를 API 게이트웨이 뒤에 쉽게 배포 가능<br>
=> 서버리스 Next.js 애플리케이션의 구축과 설정을 간소화

```js
// 서버리스 함수 예시
// app/api/hello/route.js
export async function GET() {
  return Response.json({ text: "Hello" });
}
// /api/hello 엔드포인트에서 독립적으로 배포될 수 있는 서버리스 함수
```

## 3.3.2 전통적 서버 기반 아키텍처: 특징과 선택 기준
