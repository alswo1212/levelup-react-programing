# 5.2 리액트 컴포넌트와 속성

컴포넌트 - 리액트 애플리케이션의 기본적인 구성요소<br>
리액트 요소를 반환하는 js 함수

리액트 요소 - UI를 구성하는 기본적인 블록<br>
불변성이 있으며 UI을 특정 부분을 표현해야함

## 5.2.1 리액트 서버 및 클라이언트 컴포넌트

#### 리액트 서버 컴포넌트

빌드 시에 실행되어 js 번들에서 제외돼 파일 시스템 읽기나 정적 콘텐츠 가져오기 등의 작업을 수행함<br>
서버에서 실행되어 데이터 레이어에 직접 접근이 가능함

> #### 클라이언트 컴포넌트
>
> 대화형으로 브라우저에서 실행되며 사용자 상호작용을 처리함

서버 컴포넌트에서 `use client` 와 `use server`는 <br>
컴포넌트가 클라이언트 혹은 서버에서 실행되어야 함을 명시함

서버 컴포넌트에서 데이터를 가져오고자 `async/await`을 통해 비동기 데이터 로딩을 간소화함

Next.js 앱 라우터와 통합되어 있어 <br>
서버 컴포넌트를 주요 구성 요소로 사용하는 라우터와 깊은 통합을 보여줌

> `7.1 리액트 서버/클라이언트를 활용한 렌더링 방식` 와 <br/> `7.5 서버와 클라이언트 컴포넌트의 유연한 조합 전략` 에서 자세히 다룸

### 실습 코드를 리액트 서버 및 클라이언트 컴포넌트로 분할

levelup-react/app/item-list.tsx 의 ItemList 컴포넌트를 <br/>
서버 컴포넌트와 클라이언트 컴포넌트로 구분해보자

서버 컴포넌트는 정적인 데이터 처리에 집중하고<br/>
클라이언트 컴포넌트는 동적인 사용자 상호작용을 처리하는 데 중점을 둠

```ts
// 서버 컴포넌트 부분
type Props = {
  name: string;
  age?: number;
};

function Welcome(props: Props) {
  return <h4>Hello, {props.name}</h4>;
}

function BasicList() {
  return (
    <>
      <Welcome name="Alice" />
      <h5 className="text-xl font-bold">웹 기본</h5>
      <h1 className="text-2xl font-bold">구성 요소</h1>
    </>
  );
}

export default BasicList;
```

Next.js 에서는 `use client`, `use server` 지시어가 없으면 서버 컴포넌트로 간주

```ts
// 클라이언트 컴포넌트 부분
"use client";

import React, { useState } from "react";

function ItemList({ initialItems }: { initialItems: string[] }) {
  const [items, setItems] = useState(initialItems);
  const [inputValue, setInputValue] = React.useState<string>("");

  const addItem = () => {
    setItems([...items, inputValue]);
    setInputValue("");
  };

  return (
    <div>
      <ul id="itemList" className="listdisc list-inside">
        {items.map((item, index) => (
          <li key={index}>{item}</li>
        ))}
      </ul>
      <input
        type="text"
        value={inputValue}
        onChange={(e) => setInputValue(e.target.value)}
        placeholder="항목 추가"
      />
      <button onClick={addItem}>항목 추가</button>
    </div>
  );
}

export default ItemList;
```

```ts
// 부모 페이지 컴포넌트
import BasicList from "./basic-list-server";
import ItemList from "./item-list-client";

export default function Home() {
  const items = ["HTML", "자바스크립트", "CSS"];

  return (
    <main className="flex flex-col p-4">
      <BasicList />
      <ItemList initialItems={items} />
    </main>
  );
}
```

위 코드의 결과를 확인하려면 웹 브라우저에서 http://localhost:3000/server-component 로 접속하면 됨

> 위 라우팅 방식은 Next.js 의 라우팅 방식에 따른 것인데
> <br/> `6.2 Next.js 앱 라우터 기반 라우팅 기법` 에서 자세히 다룸

## 5.2.2 타입스크립트 기반 함수형 컴포넌트 구조와 속성

#### 컴포넌트의 주요 특징

- 구조가 간경하고 일반적으로 js 함수나 ES6 화살표 함수로 작성됨
- JSX 나 다른 컴포넌트를 반환하며 브라우저에서 렌더링될 UI를 나타냄
- 컴포넌트로 전달된 데이터는 함수의 인자를 통해 접근하며 이를 속성(props)이라 부름
- 상태 관리나 사이드 이펙트 처리 등을 하는 대 리액트의 훅(Hooks)을 사용 가능
- 클래스 컴포넌트와 달리 함수형 컴포넌트는 대부분 자체 상태를 갖지 않고 필요할 때 훅을 통해 상태 관리를 수행

### JS 함수나 ES6 화살표 함수의 구조

```ts
// 일반적인 TS를 사용한 함수의 형태
type Props = { name: string };

function Welcome(props: Props) {
  return <h1>Hello, {props.name}</h1>;
}
```

```ts
// 화살표 함수의 형태
type WelcomeProps = { name: string };

// 함수형 컴포넌트를 선언하는 가장 쉬운 방법: 반환타입이 추론됨
const Welcome = ({ name }: WelcomeProps) => <h1>Hello, {name}</h1>;

// 반환 타입을 명시적으로 지정해 다른 타입 반환 시 오류 발생
const Welcome = ({ name }: WelcomeProps): React.JSX.Element => (
  <h1>Hello, {name}</h1>
);

// 타입 선언 인라인으로도 가능
const Welcome = ({ name }: { name: string }) => <h1>Hello, {name}</h1>;

// React.FunctionComponent 또는 React.FC 사용 가능
// 최신 React 타입과 TypeScript 5.1을 사용한다면 권장 X
const Welcome: React.FunctionComponent<{ name: string }> = ({ name }) => (
  <h1>Hello, {name}</h1>
);
```

일반적으로 화살표 함수를 사용한 컴포넌트를 구조화함

### 속성에 대한 정의 가능한 타입형

`number`, `string`, `string[]`, `boolean` 등등..

ts 에서 유니온 타입을 사용해 여러 타입 중 하나를 표현 가능함

`"waiting" | "success"` 처럼 표현하면 해당 속성이 `"waiting"` 또는 `"success"` 값을 갖는 다는 의미임

함수 타입도 속성으로 자주 사용되며 컴포넌트가 특정 작업을 수행하고자 외부에서 함수를 받을 때 유용

? 기호를 통해 특정 속성을 선택적인 값이라고 명시 가능<br/>
그래면 해당 속성이 제공되지 않아도 정상적으로 작동함

### 컴포넌트에서 기본 속성값을 설정

클래스 컴포넌트에서 사용되던 defaultProps 기능과 같음

```ts
// age 를 제공되지 않을 떼 기본값으로 21이 할당
type GreetProps = { age?: number };

const Greet = ({ age = 21 }: GreetProps) => {
  return <div>Age: {age}</div>;
};
```

### 속성의 타입을 type과 interface 형태로 정의가능

ts 에서 속성 정의 시 type 과 interface 두가지 방법을 사용

#### type 사용 시

```ts
type WelcomeProps = { name: string };

const Welcome = ({ name }: WelcomeProps) => <h1>Hello, {name}</h1>;

// 이 방법은 유니온 타입을 정의 하는데 유용함
type WelcomProps = { name: string | null };

const Welcome = ({ name }: WelcomProps) => {
  if (name === null) {
    return <h1>Hello, Guest</h1>;
  }
  return <h1>Hello, {name}</h1>;
};
```

```ts
// 컴포넌트 사용 예시
const App = () => {
  return (
    <div>
      <Welcome name="John" /> /* 이름이 있을 때 */
      <Welcome name={null} /> /* 이름이 없을 때 */
    </div>
  );
};
```

name 속성 자체를 생략 가능하게 하려면

```ts
type WelcomeProps = { name?: string | null };

const Welcome = ({ name = "Guest" }: WelcomProps) => <h1>Hello, {name}</h1>;
```

#### interface 사용 시

```ts
interface WelcomeProps {
  name: string;
}

const Welcome = ({ name }: WelcomeProps) => <h1>Hello, {name}</h1>;
```

`interface` 는 라이브러리나 외부 타입 정의를 작서할 때 추천됨<br/>
사용자가 선언 병합을 해 타입을 확장할 수 있어 확장 가능한 타입 정의에 적합함

```ts
// WelcomeProps 확장 예
interface BasicProps {
  greeting: string;
}

interface Welcomprops extends BasicProps {
  name: string;
}

const Welcom = ({ name, greeting }: WelcomeProps) => (
  <h1>
    {greeting}, {name}
  </h1>
);
```

### 함수형 컴포넌트의 반환형은 JSX나 다른 컴포넌트

제곧내

### 로직을 구현하는 함수형 컴포넌트 내부 상수와 함수사용

컴포넌트 내부에 상수와 내부 함수를 선언 할 수 있음

저들을 사용해 컴포넌트 구조를 간결하게 유지하고 효율적인 로직 처리를 가능하게 함

### 그 외 함수형 컴포넌트 구성 요소와 방식

- **상태(state)**<br/>
  컴포넌트 내부에서 관리되는 데이터<br/>
  `useState` 훅을 활용해 생성 및 관리하며, 컴포넌트의 렌더링과 상호작용에 따라 변화
- **효과(effect)**<br/>
  컴포넌트의 생명 주기에 맞춰 실행해야할 부수 효과들을 처리하고자 `useEffect` 훅을 사용
  데이터 로딩, 구독 설정 등 기타 작업 수행에 적합
- **커스텀 훅(Custom Hooks)**<br/>
  특정 로직을 재사용하고자 사용자 정의 훅을 만듦<br/>
  코드의 재사용성을 높이고 일관된 로직의 적용을 가능하게 함
- **이벤트 핸들러(Event Handlers)**<br/>
  사용자의 입력이나 상호작용에 반응하는 함수들
- **조건부 렌더링(Conditional Rendering)**<br/>
  특정 조건에 따라 다른 컴포넌트나 요소를 렌더링하는 방법
- **리스트와 키(Lists and Keys)**<br/>
  데이터의 목록을 반복적으로 렌더링할 때 사용됨<br/>
  각 목록에 고유한 `key`를 할당되어야 하고 이는 리액트가 항목을 효율적으로 관리하는데 도움이 됨

## 5.2.3 상태 관리 훅: 함수형 컴포넌트에서 상태 관리

#### 훅(Hooks)의 도입 목적

- 복잡한 클래스 컴포넌트를 단순화
- 코드의 재사용성 향상

훅이라는 이름은 리액트의 핵심 기능에 걸리는(hook into) 방식으로 작동한다는 의미임

훅은 함수형 컴포넌트의 내부 기능에 접근하여 <br/>
리액트의 상태나 생명 주기 등의 기능에 연결하여 사용하게 해줌

### 상태를 관리하는 useState 로 보는 훅의 이해

useState는 리액트 함수형 컴포넌트에서 상태관리를 가능하게 해주는 훅임

컴포넌트 내에서 동적 데이터를 저장하고 변경하는 역할

상태의 현재 값을 나타내는 변수와 상태를 업데이트하는 함수를 반환

```ts
const [value, setValue] = useState(initialValue);
```

`setValue`를 통해 상태를 변경하면 컴포넌트는 재렌더링되어 최신상태를 반영하게 됨

> 상태와 속성의 주요 차이점은 <br/>
> 속성은 컴포넌트 외부에서 정의 되고 상태는 컴포넌트 내부에서 정의됨

## 5.2.4 이펙트 훅: 함수형 컴포넌트에서 직접적인 렌더링이 아닌 부수 효과

`useEffect` 훅은 다양한 부수 효과를 처리하는 데 필수적인 도구임

```ts
// useEffect 훅의 구조
useEffect(() => {
  // 부수 효과를 수행하는 코드
  return () => {
    // 저리(clean-up) 코드(선택적)
  };
}, [dependencies]);
```

#### 컴포넌트 생명 주기에 따른 useEffect 실행

1. 컴포넌트 마운트 후<br/>
   컴포넌트가 처음 렌더링 된 후에 `useEffect` 내의 코드가 실행됨
2. 컴포넌트 업데이트 후<br/>
   `useEffect`가 의존성 배열에 지정된 변수들의 변경을 감지할 때 실행
3. 컴포넌트 언마운드 시<br/>
   `useEffect` 내에서 반환된 클린업 함수는 컴포넌트가 DOM에서 제거될 때 실행됨

### 이벤트 훅 사용 예

```ts
"use client";
import { useEffect, useState } from "react";

function CounterEffect() {
  const [count, setCount] = useState(0);
  const [messages, setMessages] = useState<string[]>([]);

  // 컴포넌트 마운트 후 실행
  useEffect(() => {
    setMessages((prev) => [...prev, "컴포넌트가 마운트 되었습니다."]);
    console.log("컴포넌트가 마운트 되었습니다.");

    // 컴포넌트 언마운트 시 실행될 클린업 함수
    return () => {
      // 클린업 함수의 메시지는 실제로 화면에 표시되지 않음
      setMessages((prev) => [...prev, "컴포넌트가 언마운트 되었습니다."]);
      console.log("컴포넌트가 언마운트 되었습니다.");
    };
  }, []);

  // count 상태가 변경될 때마다 실행
  useEffect(() => {
    setMessages((prev) => [...prev, `카운트가 업데이트되었습니다: ${count}`]);
    console.log(`카운트가 업데이트되었습니다: ${count}`);
  }, [count]);

  return (
    <div className="flex flex-col items-center justify-center p-4">
      <div className="h-40 p-2 mb-4 overflow-auto border border-gray-300 w-80">
        {messages.map((msg, index) => (
          <p key={index} className="text-sm text-gray-700">
            {msg}
          </p>
        ))}
      </div>
      <div className="flex flex-col items-center">
        <p className="mb-2 text-lg font-bold">카운트: {count}</p>
        <button
          onClick={() => setCount(count + 1)}
          className="px-4 py-2 font-semibold text-white bg-blue-500 hover:bg-blue-700"
        >
          증가
        </button>
      </div>
    </div>
  );
}

export default CounterEffect;
```

```ts
// 확인을 위한 부모 페이지
import CounterEffect from "./counter-effecet";

export default function Page() {
  return (
    <main className="flex flex-col p-4 space-y-2">
      <CounterEffect />
    </main>
  );
}
```

## 5.2.5 재사용 가능하고 확장성 있는 컴포넌트 디자인: 패턴과 실천 방법

리액트 개발의 핵심 철학은 재사용 가능하고 확장성 있는 컴포넌트를 만드는것

### 컴포지션(Composition) 관점에서 사고하기

작은 컴포넌트를 조합하여 큰 컴포넌트를 만드는 방식

UI를 볼 때 작은 컴포넌트로 나눠서 봐야함

```ts
// 카드를 사진과 내용 버튼으로 분리하여 봄
"use client";

interface ProfilePictureProps {
  src: string;
}

interface ProfileDetailsProps {
  name: string;
  email: string;
}

interface ContactButtonProps {
  onClick: () => void;
}

interface UserProfileCardProps {
  user: {
    profilePicture: string;
    name: string;
    email: string;
  };
  onContactClick: () => void;
}

const ProfilePicture = ({ src }: ProfilePictureProps) => {
  return (
    <img
      src={src}
      alt="Profile"
      className="w-24 h-24 border-2 border-gray-300 rounded-full"
    />
  );
};

const ProfileDetails = ({ name, email }: ProfileDetailsProps) => {
  return (
    <div className="text-left">
      <h3 className="text-xl font-bold">{name}</h3>
      <p className="text-sm text-gray-600">{email}</p>
    </div>
  );
};

const ContactButton = ({ onClick }: ContactButtonProps) => {
  return (
    <button
      onClick={onClick}
      className="px-4 py-2 font-bold text-white bg-blue-500 rounded hover:bg-blue-700"
    >
      Contact
    </button>
  );
};

export const UserProfileCard = ({
  onContactClick,
  user,
}: UserProfileCardProps) => {
  return (
    <div className="flex flex-col items-center p-4 bg-white rounded shadow-lg">
      <ProfilePicture src={user.profilePicture} />
      <ProfileDetails name={user.name} email={user.email} />
      <ContactButton onClick={onContactClick} />
    </div>
  );
};

export default UserProfileCard;
```

```ts
// 컴포넌트를 사용하는 컴포넌트
"use client";

import UserProfileCard from "./user-profile-card";

export default function UserDetail() {
  const user = {
    profilePicture: "profile/1.png",
    name: "John Doe",
    email: "john@example.com",
  };

  const handleContactClick = () => window.alert(`Contact button clicked!`);

  return (
    <>
      <h1>사용자 프로필</h1>
      <UserProfileCard user={user} onContactClick={handleContactClick} />
    </>
  );
}
```

일반적으로 정적 파일들은 public 폴더안에 저장됨

```ts
// page 코드
import UserDetail from "./user-detail";

export default function Home() {
  return (
    <main className="flex flex-col p-4">
      <UserDetail />
    </main>
  );
}
```

### 상태보다는 속성 활용

리액트에서 상태는 필요한 최상위 컴포넌트에 위치해서 필요한 컴포넌트로는 속성으로 전달해야함<br/>
이런 구현방법을 상태 끌어올리기(lifting state up) 라고 함<br/>
이를 통해 더 재사용 가능하고 확장성 있는 컴포넌트를 만들 수 있음

On, Off 상태가 있는 Toggle 컴포넌트가 있다고 가정할 때 <br/>
다른 컴포넌트에서 이 상태를 알 필요가 있다면 이 상태는 Toggle 컴포넌트 안에 있으면 안됨

```ts
"use client";

import { useState } from "react";

type ToggleProps = {
  isOn: boolean;
  onClick: () => void;
};

const Toggle = ({ isOn, onClick }: ToggleProps) => {
  return (
    <button
      onClick={onClick}
      className={`px-4 py-2 text-white font-bold rounded ${
        isOn ? "bg-blue-500" : "bg-red-400"
      }`}
    >
      {isOn ? "On" : "Off"}
    </button>
  );
};

const StatusDisplay = ({ isOn }: { isOn: boolean }) => {
  return (
    <div className={`text-lg ${isOn ? "text-blue-500" : "text-red-100"}`}>
      {isOn ? "상태 켜짐" : "상태 꺼짐"}
    </div>
  );
};

const ToggleParentComponent = () => {
  const [isToggled, setIsToggled] = useState(false);

  return (
    <div
      className={`flex flex-col items-center justify-center space-y-4 p-4 ${
        isToggled ? "bg-blue-100" : "bg-red-600"
      }`}
    >
      <Toggle isOn={isToggled} onClick={() => setIsToggled(!isToggled)} />
      <StatusDisplay isOn={isToggled} />
    </div>
  );
};

export default ToggleParentComponent;
```

```ts
// 부모 페이지
import ToggleParentComponent from "./toggle";

export default function Home() {
  return (
    <main className="flex flex-col p-4">
      <ToggleParentComponent />
    </main>
  );
}
```
